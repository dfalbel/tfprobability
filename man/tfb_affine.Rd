% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bijectors.R
\name{tfb_affine}
\alias{tfb_affine}
\title{`Affine` bijector.}
\usage{
tfb_affine(shift = NULL, scale_identity_multiplier = NULL,
  scale_diag = NULL, scale_tril = NULL, scale_perturb_factor = NULL,
  scale_perturb_diag = NULL, adjoint = FALSE, validate_args = FALSE,
  name = "affine", dtype = NULL)
}
\arguments{
\item{shift}{Floating-point `Tensor`. If this is set to `NULL`, no shift is applied.}

\item{scale_identity_multiplier}{floating point rank 0 `Tensor` representing a scaling done
to the identity matrix. When `scale_identity_multiplier = scale_diag = scale_tril = None` then
`scale += IdentityMatrix`. Otherwise no scaled-identity-matrix is added to `scale`.}

\item{scale_diag}{Floating-point `Tensor` representing the diagonal matrix.
`scale_diag` has shape `[N1, N2, ...  k]`, which represents a k x k diagonal matrix.
When `NULL` no diagonal term is added to `scale`.}

\item{scale_tril}{Floating-point `Tensor` representing the lower triangular matrix.
`scale_tril` has shape `[N1, N2, ...  k, k]`, which represents a k x k lower triangular matrix.
When `None` no `scale_tril` term is added to `scale`. The upper triangular elements above the diagonal are ignored.}

\item{scale_perturb_factor}{Floating-point `Tensor` representing factor matrix with last
two dimensions of shape `(k, r)`. When `NULL`, no rank-r update is added to `scale`.}

\item{scale_perturb_diag}{Floating-point `Tensor` representing the diagonal matrix.
`scale_perturb_diag` has shape `[N1, N2, ...  r]`, which represents an `r x r` diagonal matrix.
When `None` low rank updates will take the form `scale_perturb_factor * scale_perturb_factor.T`.}

\item{adjoint}{Logical indicating whether to use the `scale` matrix as specified or its adjoint.
Default value: `FALSE`.}

\item{validate_args}{Logical, default `FALSE`. Whether to validate input with asserts. If `validate_args` is
`FALSE`, and the inputs are invalid, correct behavior is not guaranteed.}

\item{name}{name prefixed to Ops created by this class.}

\item{dtype}{`tf$DType` to prefer when converting args to `Tensor`s. Else, we fall back to a
common dtype inferred from the args, finally falling back to float32.}
}
\description{
This `Bijector` is initialized with `shift` `Tensor` and `scale` arguments,
giving the forward operation: `Y = g(X) = scale @ X + shift``
where the `scale` term is logically equivalent to:
scale =
    scale_identity_multiplier * tf.diag(tf.ones(d)) +
    tf.diag(scale_diag) +
    scale_tril +
    scale_perturb_factor @ diag(scale_perturb_diag) @ tf.transpose([scale_perturb_factor]))
}
\details{
If none of `scale_identity_multiplier`, `scale_diag`, or `scale_tril` are specified then
  `scale += IdentityMatrix`. Otherwise specifying a `scale` argument has the semantics of
   `scale += Expand(arg)`, i.e., `scale_diag != NULL` means `scale += tf$diag(scale_diag)`.
}
